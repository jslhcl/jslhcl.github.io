---
layout:	post
title:	"Structure and Interpretation of Computer Programs notes II"
date:	2014-04-13
---
# Chapter 2. Building Abstractions with Data

## 1. Pairs

{% highlight Scheme %}
(define x (cons 1 2))

(car x)
1

(cdr x)
2

(define x (cons 1 2))
(define y (cons 3 4))
(define z (cons x y))
(car (car z))
1
(car (cdr z))
3

(define (make-rat n d)
	(let ((g (gcd n d)))
	     (cons (/ n g) (/ d g)))) 

(define (numer x) (car x))
(define (denom x) (cdr x))
{% endhighlight %}

The ability to manipulate procedures as objects automatically provides the ability to represent compound data. This style of programming is often called *message passing* 

## 2. list

Scheme provides a primitive called *list* to help in constructing lists. In general, 

(list <a1> <a2> ... <an>)

is equivalent to

(cons <a1> (cons <a2> (cons ... (cons <an> nil) ... )))

{% highlight Scheme %}
(define one-through-four (list 1 2 3 4))

(car one-through-four)
1
(cdr one-through-four)
(2 3 4)

(cons 10 one-through-four)
(10 1 2 3 4)

(define (list-ref items n)
	(if (= n 0)
	    (car items)
	    (list-ref (cdr items) (- n 1))))

(define (length items)
	(if (null? items)
	    0
	    (+ 1 (length (cdr items)))))

(define (length items)
	(define (length-iter a count)
		(if (null? a)
		    count
		    (length-iter (cdr a) (+ 1 count))))
	(length-iter items 0))

(define (append list1 list2)
	(if (null? list1)
	    list2
	    (cons (car list1) (append (cdr list1) list2))))
{% endhighlight %}

The value of *nil*, used to terminate the chain of pairs, can be thought of as a sequence of no elements, the *empty list*. The word *nil* is a contraction of the Latin word *nihil*, which means "nothing"

## Exercise 2.1

{% highlight Scheme %}
(define (make-rat n d)
	(let ((nn (abs n))
	      (dd (abs d))
	      (g (gcd nn dd)))
	     (cond ((= (* n d) 0) (cons (n d)))
	           ((> (* n d) 0) (cons (/ nn g) (/ dd g)))
		   (else (cons (- (/ nn g)) (/ dd g))))))	
{% endhighlight %}

## Exercise 2.2

{% highlight Scheme %}
(define (make-point x y) (cons x y))
(define (x-point p) (car p))
(define (y-point p) (cdr p))

(define (make-segment pstart pend) (cons pstart pend))
(define (start-segment segment) (car segment))
(define (end-segment segment) (cdr segment))

(define (mid-segment segment) 
	(let ((xmid (/ (+ (x-point (start-segment segment)) (x-point (end-segment segment))) 2))
	      (ymid (/ (+ (y-point (start-segment segment)) (y-point (end-segment segment))) 2)))
	     (make-point xmid ymid)))
{% endhighlight %}

## Exercise 2.3

{% highlight Scheme %}
(define (make-rect pLT pRB) (cons pLT pRB))
(define (area rect)
	(let ((height (abs (- (x-point pLT) (x-point pRB))))
	      (width  (abs (- (y-point pLT) (y-point pRB)))))
	     (* height width)))
(define (perimeter rect)
	(let ((height (abs (- (x-point pLT) (x-point pRB))))
	      (width  (abs (- (y-point pLT) (y-point pRB)))))
	     (+ height height width width)))
{% endhighlight %}

## Exercise 2.4

{% highlight Scheme %}
(define (cons x y)
	(lambda (m) (m x y)))

(define (car z)
	(z (lambda (p q) p)))

(define (cdr z)
	(z (lambda (p q) q)))
{% endhighlight %}

## Exercise 2.5

{% highlight Scheme %}
(define (cons x y)
	(* (expt 2 x) (expt 3 y)))

(define (logNum base value ret)
	(if (= 0 (remainder value base))
	    (logNum base (/ value base) (+ 1 ret))
	    ret))

(define (car z)
	(logNum 2 z 0))

(define (cdr z)
	(logNum 3 z 0))
{% endhighlight %}

## Exercise 2.6

{% highlight Scheme %}
(define one (lambda (f) (lambda (x) (f x))))

(define two (lambda (f) (lambda (x) (f (f x)))))

(define (plus n1 n2)
	(lambda (f) (lambda (x) ((n1 f) ((n2 f) x)))))
{% endhighlight %}

[Link] (http://wqzhang.wordpress.com/2009/06/16/sicp-exercise-2-6/)

[Wiki_page](http://en.wikipedia.org/wiki/Church_encoding)

## Exercise 2.7

{% highlight Scheme %}
(define (upper-bound interval) (cdr interval))

(define (lower-bound interval) (car interval))
{% endhighlight %}

## Exercise 2.8

{% highlight Scheme %}
(define (sub-interval x y)
	(make-interval (- (lower-bound x) (upper-bound y))
	               (- (upper-bound x) (lower-bound y))))
{% endhighlight %}

## Exercise 2.10

{% highlight Scheme %}
(define (div-interval x y)
	(if (<= (* (lower-bound y) (upper-bound y)) 0)
	    (error "y spans zero")
	    (mul-interval x (make-interval (/ 1.0 (upper-bound y))
	    				   (/ 1.0 (lower-bound y))))))
{% endhighlight %}

## Exercise 2.12

{% highlight Scheme %}
(define (make-center-percent c p)
	(make-interval (* c (- 1 (/ p 100))) (* c (+ 1 (/ p 100)))))
{% endhighlight %}

## Exercise 2.17

{% highlight Scheme %}
(define (last-pair items)
  	(if (= (length items) 1)
	    (car items)
	    (last-pair (cdr items))))
{% endhighlight %}

## Exercise 2.18

{% highlight Scheme %}
(define (reverse items)
	(if (null? items)
	    items
	    (append (reverse (cdr items)) (list (car items))))) 
{% endhighlight %}

## Exercise 2.19

{% highlight Scheme %}
(define (first-denomination items)
	(car items))

(define (except-first-denomination items)
	(cdr items))

(define (no-more? items)
	(null? items))
{% endhighlight %}

## Exercise 2.20

{% highlight Scheme %}
(define (same-parity first . rest)
	(define (same-parity-iter first n . rest)
		(

{% endhighlight %}
