---
layout:	post
title:	"Structure and Interpretation of Computer Programs notes II"
date:	2014-04-13
---
# Chapter 2. Building Abstractions with Data

## 1. Pairs

{% highlight Scheme %}
(define x (cons 1 2))

(car x)
1

(cdr x)
2

(define x (cons 1 2))
(define y (cons 3 4))
(define z (cons x y))
(car (car z))
1
(car (cdr z))
3

(define (make-rat n d)
	(let ((g (gcd n d)))
	     (cons (/ n g) (/ d g)))) 

(define (numer x) (car x))
(define (denom x) (cdr x))
{% endhighlight %}

The ability to manipulate procedures as objects automatically provides the ability to represent compound data. This style of programming is often called *message passing* 

## 2. list

Scheme provides a primitive called *list* to help in constructing lists. In general, 

(list <a1> <a2> ... <an>)

is equivalent to

(cons <a1> (cons <a2> (cons ... (cons <an> nil) ... )))

{% highlight Scheme %}
(define one-through-four (list 1 2 3 4))

(car one-through-four)
1
(cdr one-through-four)
(2 3 4)

(cons 10 one-through-four)
(10 1 2 3 4)

(define (list-ref items n)
	(if (= n 0)
	    (car items)
	    (list-ref (cdr items) (- n 1))))

(define (length items)
	(if (null? items)
	    0
	    (+ 1 (length (cdr items)))))

(define (length items)
	(define (length-iter a count)
		(if (null? a)
		    count
		    (length-iter (cdr a) (+ 1 count))))
	(length-iter items 0))

(define (append list1 list2)
	(if (null? list1)
	    list2
	    (cons (car list1) (append (cdr list1) list2))))
{% endhighlight %}

The value of *nil*, used to terminate the chain of pairs, can be thought of as a sequence of no elements, the *empty list*. The word *nil* is a contraction of the Latin word *nihil*, which means "nothing"

Scheme provided the primitive predictor *pair?* which tests whether its argument is a pair.

{% highlight Scheme %}
(define (count-leaves x)
	(cond ((null? x) 0)
	      ((not (pair? x)) 1)
	      (else (+ (count-leaves (car x)) (count-leaves (cdr x))))))
{% endhighlight %}

## 3. Mapping 

{% highlight Scheme %}
(define (scale-list items factor)
	(if (null? items)
	    nil
	    (cons (* (car items) factor)
	          (scale-list (cons items) factor))))

(define (scale-tree tree factor)
	(cond ((null? tree) nil)
	      ((not (pair? tree)) (* tree factor))
	      (else (cons (scale-tree (car tree) factor) (scale-tree (cdr tree) factor)))))
{% endhighlight %}

## Exercise 2.1

{% highlight Scheme %}
(define (make-rat n d)
	(let ((nn (abs n))
	      (dd (abs d))
	      (g (gcd nn dd)))
	     (cond ((= (* n d) 0) (cons (n d)))
	           ((> (* n d) 0) (cons (/ nn g) (/ dd g)))
		   (else (cons (- (/ nn g)) (/ dd g))))))	
{% endhighlight %}

## Exercise 2.2

{% highlight Scheme %}
(define (make-point x y) (cons x y))
(define (x-point p) (car p))
(define (y-point p) (cdr p))

(define (make-segment pstart pend) (cons pstart pend))
(define (start-segment segment) (car segment))
(define (end-segment segment) (cdr segment))

(define (mid-segment segment) 
	(let ((xmid (/ (+ (x-point (start-segment segment)) (x-point (end-segment segment))) 2))
	      (ymid (/ (+ (y-point (start-segment segment)) (y-point (end-segment segment))) 2)))
	     (make-point xmid ymid)))
{% endhighlight %}

## Exercise 2.3

{% highlight Scheme %}
(define (make-rect pLT pRB) (cons pLT pRB))
(define (area rect)
	(let ((height (abs (- (x-point pLT) (x-point pRB))))
	      (width  (abs (- (y-point pLT) (y-point pRB)))))
	     (* height width)))
(define (perimeter rect)
	(let ((height (abs (- (x-point pLT) (x-point pRB))))
	      (width  (abs (- (y-point pLT) (y-point pRB)))))
	     (+ height height width width)))
{% endhighlight %}

## Exercise 2.4

{% highlight Scheme %}
(define (cons x y)
	(lambda (m) (m x y)))

(define (car z)
	(z (lambda (p q) p)))

(define (cdr z)
	(z (lambda (p q) q)))
{% endhighlight %}

## Exercise 2.5

{% highlight Scheme %}
(define (cons x y)
	(* (expt 2 x) (expt 3 y)))

(define (logNum base value ret)
	(if (= 0 (remainder value base))
	    (logNum base (/ value base) (+ 1 ret))
	    ret))

(define (car z)
	(logNum 2 z 0))

(define (cdr z)
	(logNum 3 z 0))
{% endhighlight %}

## Exercise 2.6

{% highlight Scheme %}
(define one (lambda (f) (lambda (x) (f x))))

(define two (lambda (f) (lambda (x) (f (f x)))))

(define (plus n1 n2)
	(lambda (f) (lambda (x) ((n1 f) ((n2 f) x)))))
{% endhighlight %}

[Link] (http://wqzhang.wordpress.com/2009/06/16/sicp-exercise-2-6/)

[Wiki_page](http://en.wikipedia.org/wiki/Church_encoding)

## Exercise 2.7

{% highlight Scheme %}
(define (upper-bound interval) (cdr interval))

(define (lower-bound interval) (car interval))
{% endhighlight %}

## Exercise 2.8

{% highlight Scheme %}
(define (sub-interval x y)
	(make-interval (- (lower-bound x) (upper-bound y))
	               (- (upper-bound x) (lower-bound y))))
{% endhighlight %}

## Exercise 2.10

{% highlight Scheme %}
(define (div-interval x y)
	(if (<= (* (lower-bound y) (upper-bound y)) 0)
	    (error "y spans zero")
	    (mul-interval x (make-interval (/ 1.0 (upper-bound y))
	    				   (/ 1.0 (lower-bound y))))))
{% endhighlight %}

## Exercise 2.12

{% highlight Scheme %}
(define (make-center-percent c p)
	(make-interval (* c (- 1 (/ p 100))) (* c (+ 1 (/ p 100)))))
{% endhighlight %}

## Exercise 2.17

{% highlight Scheme %}
(define (last-pair items)
  	(if (= (length items) 1)
	    (car items)
	    (last-pair (cdr items))))
{% endhighlight %}

## Exercise 2.18

{% highlight Scheme %}
(define (reverse items)
	(if (null? items)
	    items
	    (append (reverse (cdr items)) (list (car items))))) 
{% endhighlight %}

## Exercise 2.19

{% highlight Scheme %}
(define (first-denomination items)
	(car items))

(define (except-first-denomination items)
	(cdr items))

(define (no-more? items)
	(null? items))
{% endhighlight %}

## Exercise 2.20

{% highlight Scheme %}
(define (same-parity first . rest)
	(define (same-parity-iter ret rest)
		(if (null? rest)
		    ret
		    (if (odd? (+ first (car rest)))
		         (same-parity-iter ret (cdr rest))
			 (same-parity-iter (append ret (list (car rest))) (cdr rest)))))
	(same-parity-iter (list first) (cdr rest)))
{% endhighlight %}

## Exercise 2.21

{% highlight Scheme %}
(define (square-list items)
	(if (null? items)
	nil
	(cons (* (car items) (car items)) (square-list (cdr items)))))

(define (square-list items)
	(map square items))
{% endhighlight %}

## Exercise 2.23

{% highlight Scheme %}
(define (for-each f li)
  	(if (null? li)
	    li
	    (cons (f (car li)) (for-each f (cdr li)))))
{% endhighlight %}

## Exercise 2.25

{% highlight Scheme %}
(car (cdr (car (cdr (cdr '(1 3 (5 7) 9))))))

(car (car '((7))))

(car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr '(1 (2 (3 (4 (5 (6 7))))))))))))))))))
{% endhighlight %}

## Exercise 2.26

{% highlight Scheme %}
(1 2 3 4 5 6)		;append

((1 2 3) 4 5 6)		;cons

((1 2 3) (4 5 6))	;list
{% endhighlight %}

## Exercise 2.27

{% highlight Scheme %}
(define (deep-reverse li)
	(define (f re-li)
		(cond ((null? re-li) '())
		      ((pair? (car re-li)
		       (append (reverse (car re-li)) (f (cdr re-li)))))
		      (else (append (list (car re-li)) (f (cdr re-li))))))
	(f (reverse li)))
{% endhighlight %}

## Exercise 2.28

{% highlight Scheme %}
(define (fringe li)
	(cond ((null? li) '())
	      ((pair? (car li))
	       (append (fringe (car li)) (fringe (cdr li))))
	      (else (append (list (car li)) (fringe (cdr li))))))
{% endhighlight %}

## Exercise 2.29

{% highlight Scheme %}
(define (left-branch mobile)
	(car mobile))

(define (right-branch mobile)
	(car (cdr mobile)))

(define (branch-length branch)
	(car branch))

(define (branch-structure branch)
	(car (cdr branch)))

(define (branch-weight branch)
	(if (not (pair? (branch-structure branch)))
	    (branch-structure branch)
	    (+ (branch-weight (left-branch (branch-structure branch))) (branch-weight (right-branch (branch-structure branch))))))

(define (total-weight mobile)
	(+ (branch-weight (left-branch mobile)) (branch-weight (right-branch mobile))))

(define (balanced? mobile)
	(if (pair? (car mobile))
		(let ((lb (left-branch mobile))
		      (rb (right-branch mobile)))
		     (and (= (* (branch-length lb) (branch-weight lb)) (* (branch-length rb) (branch-weight rb)))
		          (balanced? (branch-structure lb))
			  (balanced? (branch-structure rb))))
	    true))
{% endhighlight %}

## Exercise 2.30

{% highlight Scheme %}
(define (square-tree tree)
	(cond ((null? tree) nil)
	      ((not (pair? tree)) (* tree tree))
	      (else (cons (square-tree (car tree)) (square-tree (cdr tree))))))

(define (square-tree2 tree)
	(map (lambda (sub-tree)
	             (if (pair? sub-tree)
	         	 (square-tree2 sub-tree)
		 	 (* sub-tree sub-tree)))
	     tree))
{% endhighlight %}

## Exercise 2.31

{% highlight Scheme %}
(define (tree-map proc tree)
	(cond ((null? tree) '())
	      ((not (pair? tree)) (proc tree))
	      (else (cons (tree-map proc (car tree)) (tree-map proc (cdr tree))))))
{% endhighlight %}

## Exercise 2.32

{% highlight Scheme %}
(lambda (x) (append (list (car s)) x))
{% endhighlight %}


